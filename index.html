<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Crane Dreamscape — Floating Cranes</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body{margin:0;font-family:Inter, Roboto, Arial;background:linear-gradient(180deg,#f0fbf9,#ffffff);color:#023}
    header{background:linear-gradient(90deg,#2b8a76,#0b6a59);color:white;padding:18px;text-align:center;font-weight:700}
    .ui{max-width:980px;margin:14px auto;padding:12px;display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
    .panel{background:white;padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(10,30,30,0.06);flex:1;min-width:280px}
    label{display:block;font-weight:600;color:#0b6a59;margin-bottom:6px}
    input[type="text"], textarea{width:100%;padding:8px;border-radius:8px;border:1px solid #ccd;box-sizing:border-box}
    input[type="file"]{width:100%}
    button{background:#0b6a59;color:white;padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
    #canvas-container{max-width:1200px;margin:14px auto;border-radius:12px;overflow:hidden}
    small{color:#336}
    #status{margin-top:8px;color:#046}
    .hint{font-size:13px;color:#667}
  </style>
</head>
<body>
  <header>Crane Dreamscape — Upload & Watch</header>

  <div class="ui">
    <div class="panel">
      <h3 style="margin-top:0">Share your found crane</h3>
      <div>
        <label for="crane">Crane ID (e.g. C001)</label>
        <input id="crane" type="text" placeholder="C001">
      </div>
      <div>
        <label for="name">Name (optional)</label>
        <input id="name" type="text" placeholder="Give your crane a name">
      </div>
      <div>
        <label for="message">Message (optional)</label>
        <textarea id="message" rows="3" placeholder="A short note..."></textarea>
      </div>
      <div>
        <label for="file">Photo</label>
        <input id="file" type="file" accept="image/*">
      </div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="uploadBtn">Upload</button>
        <button id="refreshBtn" style="background:#2a5">Refresh</button>
      </div>
      <div id="status" class="hint">Status: idle</div>
      <p class="hint" style="margin-top:10px">Uploads are stored on Drive and used by everyone who visits this page.</p>
    </div>

    <div class="panel" style="flex:1.6">
      <h3 style="margin-top:0">Stage</h3>
      <div id="canvas-container"></div>
      <small class="hint">Click a crane for details (and a chime). Drag cranes to reposition them.</small>
    </div>
  </div>

<script>
/* ------------- CONFIG ------------- */
const WEBAPP_URL = "REPLACE_WITH_YOUR_WEBAPP_URL"; // e.g. https://script.google.com/macros/s/.../exec
/* ---------------------------------- */

const CHIME_FREQ = 880; // chime frequency
let synthCtx;

/* ---------- uploader logic ---------- */
document.getElementById('uploadBtn').addEventListener('click', async () => {
  const crane = document.getElementById('crane').value.trim();
  const name = document.getElementById('name').value.trim();
  const message = document.getElementById('message').value.trim();
  const fileInput = document.getElementById('file');
  const status = document.getElementById('status');

  if (!crane) { status.innerText = 'Status: Enter a crane ID (C001)'; return; }
  if (!fileInput.files.length) { status.innerText = 'Status: Select a photo to upload'; return; }

  status.innerText = 'Status: Reading file...';
  const file = fileInput.files[0];
  const dataURL = await fileToDataURL(file);

  // Build payload
  const payload = {
    action: 'upload',
    crane: crane,
    name: name,
    message: message,
    imageData: dataURL
  };

  status.innerText = 'Status: Uploading...';
  try {
    const resp = await fetch(WEBAPP_URL, {
      method: 'POST',
      body: JSON.stringify(payload),
      headers: { 'Content-Type': 'application/json' }
    });
    const json = await resp.json();
    if (json.success) {
      status.innerText = 'Status: Uploaded — saved to Drive.';
      // refresh sketch data
      await loadEntriesThenUpdate();
      // clear form lightly
      document.getElementById('file').value = '';
      setTimeout(()=> { status.innerText = 'Status: idle'; }, 2000);
    } else {
      status.innerText = 'Status: Upload failed: ' + (json.error || 'unknown');
    }
  } catch (err) {
    console.error(err);
    status.innerText = 'Status: Upload error (see console)';
  }
});

function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });
}

/* ---------- p5 sketch + scene ---------- */
let sprites = []; // will hold {img, x,y,w,h, vx, vy, angle, name,msg,ts, id, trail}
let canvasParent;
let cnv;

function loadEntriesThenUpdate(){
  // fetch list via ?action=list
  return fetch(`${WEBAPP_URL}?action=list`)
    .then(res => res.json())
    .then(j => {
      if (!j.success) return;
      // transform into sprite data (but keep existing sprites where same photo URL)
      const items = j.items || [];
      // We'll create new sprites for items that have a photo_url
      const newPhotos = items.filter(it => it.photo_url).map(it => ({
        photo_url: it.photo_url,
        crane_id: it.crane_id || '',
        name: it.name || '',
        message: it.message || '',
        ts: it.timestamp || it.timestamp // keep whichever
      }));
      // Remove duplicates by URL
      const unique = [];
      const seen = new Set();
      newPhotos.forEach(p => {
        if (p.photo_url && !seen.has(p.photo_url)) { seen.add(p.photo_url); unique.push(p); }
      });
      // Load images (asynchronously) and add sprites for those not present
      unique.forEach(p => {
        if (!sprites.find(s => s.sourceUrl === p.photo_url)) {
          // load as p5 Image using loadImage
          loadImage(p.photo_url, img => {
            // scale
            const maxDim = 160;
            let w = img.width, h = img.height;
            const scale = min(maxDim/w, maxDim/h, 1);
            w = Math.round(w * scale); h = Math.round(h * scale);
            const s = {
              id: 'srv_' + Math.floor(Math.random()*999999),
              sourceUrl: p.photo_url,
              img: img,
              x: random(w/2 + 20, width - w/2 - 20),
              y: random(h/2 + 20, height - h/2 - 20),
              w: w, h: h,
              vx: random(-0.6,0.6), vy: random(-0.4,0.4),
              angle: random(-0.3,0.3),
              noiseX: random(1000), noiseY: random(2000),
              name: p.name || p.crane_id || '',
              msg: p.message || '',
              ts: p.ts || (new Date()).toISOString(),
              trail: [] // array of {x,y,life}
            };
            sprites.push(s);
          }, err => {
            console.warn('img load err', p.photo_url, err);
          });
        }
      });
    }).catch(err => {
      console.error('list fetch err', err);
    });
}

function setup() {
  canvasParent = select('#canvas-container');
  cnv = createCanvas(canvasParent.width, 540);
  cnv.parent('canvas-container');
  pixelDensity(1);
  // initial load
  loadEntriesThenUpdate();
  // periodic refresh
  setInterval(loadEntriesThenUpdate, 20000); // every 20s
}

function windowResized(){
  const w = canvasParent.width;
  resizeCanvas(w, max(360, floor(windowHeight * 0.6)));
}

function draw() {
  // background soft gradient
  for (let i = 0; i < height; i++) {
    const t = map(i, 0, height, 0, 1);
    const r = lerp(248, 255, t);
    const g = lerp(252, 255, t);
    const b = lerp(251, 255, t);
    stroke(r, g, b);
    line(0, i, width, i);
  }

  // update & render sprites
  for (let i = 0; i < sprites.length; i++) {
    const s = sprites[i];
    // Perlin noise drift
    s.noiseX += 0.003 + (i%4)*0.0005;
    s.noiseY += 0.003 + (i%3)*0.0006;
    const nx = noise(s.noiseX + frameCount*0.001);
    const ny = noise(s.noiseY + 1000 + frameCount*0.001);
    s.vx += map(nx,0,1,-0.25,0.25);
    s.vy += map(ny,0,1,-0.16,0.16);
    // cap velocities
    s.vx *= 0.96; s.vy *= 0.96;
    s.x += s.vx; s.y += s.vy;
    s.angle += 0.002 * ((i%2) ? 1 : -1);

    // keep inside canvas
    if (s.x < s.w*0.45) { s.x = s.w*0.45; s.vx *= -0.6; }
    if (s.x > width - s.w*0.45) { s.x = width - s.w*0.45; s.vx *= -0.6; }
    if (s.y < s.h*0.45) { s.y = s.h*0.45; s.vy *= -0.6; }
    if (s.y > height - s.h*0.45) { s.y = height - s.h*0.45; s.vy *= -0.6; }

    // trails: push current pos
    s.trail.push({x: s.x, y: s.y, life: 1.0});
    if (s.trail.length > 20) s.trail.shift();
    // draw trail particles (sparkly)
    noStroke();
    for (let t = 0; t < s.trail.length; t++) {
      const p = s.trail[t];
      const alpha = map(t, 0, s.trail.length-1, 20, 180);
      fill(255, 230, 200, alpha * 0.9);
      ellipse(p.x, p.y, (s.w*0.18) * (t/s.trail.length + 0.2));
      fill(255,255,255, alpha*0.6);
      ellipse(p.x + 3*Math.sin(t*0.6 + frameCount*0.02), p.y + 3*Math.cos(t*0.4 + frameCount*0.02), 2);
    }

    // draw sprite image
    push();
    translate(s.x, s.y);
    rotate(s.angle);
    imageMode(CENTER);
    image(s.img, 0, 0, s.w, s.h);
    pop();

    // subtle shadow
    noStroke();
    fill(0, 10);
    ellipse(s.x, s.y + s.h*0.48, s.w*0.9, s.h*0.18);
  }

  // draw count
  fill(10, 60);
  noStroke();
  textSize(13);
  textAlign(LEFT, TOP);
  text(`${sprites.length} cranes`, 8, 8);
}

/* --------- interactions: clicking and dragging ---------- */
let dragTarget = null;
let offsetX = 0, offsetY = 0;
function mousePressed() {
  // find topmost sprite under mouse
  for (let i = sprites.length-1; i >= 0; i--) {
    const s = sprites[i];
    const dx = mouseX - s.x, dy = mouseY - s.y;
    const d = sqrt(dx*dx + dy*dy);
    if (d < max(s.w, s.h)*0.6) {
      // if click -> start drag, and also play chime & show small info bubble (native alert)
      dragTarget = s;
      offsetX = s.x - mouseX;
      offsetY = s.y - mouseY;
      playChime();
      showInfoBubble(s);
      return false; // prevent default
    }
  }
}

function mouseDragged() {
  if (dragTarget) {
    dragTarget.x = mouseX + offsetX;
    dragTarget.y = mouseY + offsetY;
  }
}

function mouseReleased() {
  dragTarget = null;
}

/* simple info small overlay */
function showInfoBubble(s) {
  const info = `${s.name || 'Unnamed'}\n${s.msg || ''}\nFound: ${new Date(s.ts).toLocaleString()}`;
  // small overlay using alert for simplicity
  alert(info);
}

/* --------- chime (WebAudio) ---------- */
function playChime() {
  try {
    if (!synthCtx) synthCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t = synthCtx.currentTime;
    const o = synthCtx.createOscillator();
    const g = synthCtx.createGain();
    o.type = 'sine';
    o.frequency.value = CHIME_FREQ;
    g.gain.value = 0;
    o.connect(g);
    g.connect(synthCtx.destination);
    o.start(t);
    // quick envelope
    g.gain.linearRampToValueAtTime(0.15, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
    o.stop(t + 0.8);
  } catch (e) {
    console.warn('audio fail', e);
  }
}

/* ------------- manual refresh ------------- */
document.getElementById('refreshBtn').addEventListener('click', async () => {
  document.getElementById('status').innerText = 'Status: refreshing...';
  await loadEntriesThenUpdate();
  document.getElementById('status').innerText = 'Status: idle';
});
</script>
</body>
</html>
