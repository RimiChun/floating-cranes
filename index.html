<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Crane Dreamscape — Fullscreen</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#f0fbf9,#ffffff);font-family:Inter,Roboto,Arial}
    #ui {
      position:fixed; right:18px; top:18px; z-index:999;
      background:rgba(255,255,255,0.9); border-radius:10px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.08);
      backdrop-filter: blur(4px);
      width:320px;
    }
    #ui h3{margin:0 0 8px 0;color:#0b6a59;font-size:16px}
    label{display:block;font-size:13px;color:#0b6a59;margin-bottom:6px;font-weight:600}
    input[type=text], textarea{width:100%;box-sizing:border-box;padding:8px;border-radius:8px;border:1px solid #d5e; margin-bottom:8px}
    input[type=file]{width:100%; margin-bottom:8px}
    button{background:#0b6a59;color:white;padding:9px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
    #status{font-size:13px;color:#046;margin-top:8px;min-height:18px}
    #overlayInfo {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      background:white; padding:14px; border-radius:12px; box-shadow:0 14px 48px rgba(0,0,0,0.25);
      max-width:520px; z-index:1001; display:none;
    }
    #overlayInfo img{max-width:100%; border-radius:8px; display:block; margin-bottom:10px}
    #closeOverlay{background:#eee;border-radius:8px;padding:6px 10px;border:0;cursor:pointer}
    #help {position:fixed; left:18px; bottom:18px; z-index:999; background:rgba(255,255,255,0.9); padding:10px; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.06)}
    .hint{font-size:12px;color:#445}
  </style>
</head>
<body>
  <div id="ui">
    <h3>Share a found crane</h3>
    <label for="craneId">Crane ID (e.g. C001)</label>
    <input id="craneId" type="text" placeholder="C001">
    <label for="name">Name (optional)</label>
    <input id="name" type="text" placeholder="A little friend">
    <label for="message">Message (optional)</label>
    <textarea id="message" rows="3" placeholder="A short note..."></textarea>
    <label for="file">Photo</label>
    <input id="file" type="file" accept="image/*">
    <div style="display:flex;gap:8px;margin-top:6px">
      <button id="uploadBtn">Upload</button>
      <button id="refreshBtn" style="background:#2a5">Refresh</button>
    </div>
    <div id="status" class="hint">Status: idle</div>
  </div>

  <div id="help" class="hint">Click a floating crane for details & a chime. Drag to reposition.</div>

  <div id="overlayInfo">
    <div id="overlayContent"></div>
    <div style="text-align:right;margin-top:8px">
      <button id="closeOverlay">Close</button>
    </div>
  </div>

<script>
/* ------------------------
   Edit this: replace with your deployed Apps Script URL
   Example: "https://script.google.com/macros/s/AKfy.../exec"
   ------------------------ */
const WEBAPP_URL = "https://script.google.com/macros/s/AKfycbzt6GUKLQl_1NY4yzh7Qi9uz2BtfvfPhmoQxElJ88sWyM7mSzKSmBAQcLZGcShT248/exec";
/* ------------------------ */

if (!WEBAPP_URL || WEBAPP_URL.indexOf('REPLACE_WITH') !== -1) {
  console.warn('Please set WEBAPP_URL to your Apps Script web app URL before using uploads/load.');
}

/* ---------- Helpers ---------- */
function logStatus(msg){ document.getElementById('status').innerText = 'Status: ' + msg; }

/* Convert file to base64 (DataURL), then strip prefix to get raw base64 */
function fileToBase64Str(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => {
      const data = fr.result; // data:image/png;base64,....
      const comma = data.indexOf(',');
      if (comma === -1) return resolve(data);
      resolve(data.slice(comma+1)); // raw base64
    };
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });
}

/* POST form-url-encoded (so Apps Script e.parameter sees it) */
async function postBase64(base64Str, craneId){
  // Build payload as form-urlencoded
  const body = new URLSearchParams();
  body.append('file', base64Str);
  body.append('craneId', craneId || '');
  const resp = await fetch(WEBAPP_URL, {
    method: 'POST',
    body: body
  });
  return resp.json();
}

/* ---------- p5 sketch variables ---------- */
let sprites = []; // {img, x,y,w,h, vx,vy, angle, noiseX, noiseY, name, msg, ts, url}
let canvasEl;
let canvasParentWidth = window.innerWidth;
let canvasParentHeight = window.innerHeight;

/* ---------- load list of uploaded images from Apps Script (GET returns JSON array of URLs) ---------- */
async function fetchDriveList(){
  if (!WEBAPP_URL || WEBAPP_URL.indexOf('REPLACE_WITH') !== -1) return [];
  try {
    const u = WEBAPP_URL;
    const r = await fetch(u);
    const json = await r.json();
    // If your Apps Script returns an array (as in the simple example), json is array
    // If your script returns { ... } wrap, handle both
    if (Array.isArray(json)) return json;
    if (json && json.items) return json.items;
    // If script returned {ok:true} or similar, try to parse content as array if present
    if (json && json.success && json.items) return json.items.map(it => it.photo_url || it.url).filter(Boolean);
    // fallback: if json is object with urls array
    if (json && json.urls) return json.urls;
    return [];
  } catch (err) {
    console.warn('fetchDriveList error', err);
    return [];
  }
}

/* ---------- p5 setup/draw ---------- */
function setup(){
  const cnv = createCanvas(windowWidth, windowHeight);
  cnv.position(0,0);
  cnv.style('display','block');
  pixelDensity(1);
  imageMode(CENTER);
  // initial load of Drive images
  loadServerImages();
  // periodic refresh
  setInterval(loadServerImages, 20000);
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
}

/* create sprite from loaded image */
function makeSpriteFromP5Image(img, meta){
  const maxDim = 180;
  let w = img.width, h = img.height;
  const scale = Math.min(maxDim/w, maxDim/h, 1);
  w = Math.round(w * scale); h = Math.round(h * scale);
  return {
    img,
    x: random(w/2 + 20, width - w/2 - 20),
    y: random(h/2 + 20, height - h/2 - 20),
    w, h,
    vx: random(-0.6,0.6), vy: random(-0.4,0.4),
    angle: random(-0.3,0.3),
    noiseX: random(1000), noiseY: random(2000),
    name: meta && meta.name ? meta.name : '',
    msg: meta && meta.msg ? meta.msg : '',
    ts: meta && meta.ts ? meta.ts : (new Date()).toISOString(),
    url: meta && meta.url ? meta.url : '',
    trail: []
  };
}

/* loads server images and adds sprites for new ones */
async function loadServerImages(){
  logStatus('Loading server images...');
  const list = await fetchDriveList();
  const urls = list.filter(Boolean); // all are direct now

  for (const url of urls){
    if (sprites.find(s => s.url === url)) continue;
    try {
      await new Promise((res, rej) => {
        loadImage(url, img => {
          const spr = makeSpriteFromP5Image(img, { url });
          sprites.push(spr);
          res();
        }, err => {
          console.warn('img load fail', url, err);
          res();
        });
      });
    } catch(e){ console.warn('load err', e); }
  }
  logStatus('idle');
}


/* draw loop */
function draw(){
  // subtle background gradient
  for (let i = 0; i < height; i++) {
    const t = map(i, 0, height, 0, 1);
    stroke(lerp(248,255,t), lerp(252,255,t), lerp(251,255,t));
    line(0, i, width, i);
  }

  // update & draw sprites
  for (let i = 0; i < sprites.length; i++){
    const s = sprites[i];
    s.noiseX += 0.002 + (i%4)*0.0003;
    s.noiseY += 0.002 + (i%3)*0.0004;
    const nx = noise(s.noiseX + frameCount*0.001);
    const ny = noise(s.noiseY + frameCount*0.001 + 3000);
    s.vx += map(nx,0,1,-0.22,0.22);
    s.vy += map(ny,0,1,-0.14,0.14);
    s.vx *= 0.96; s.vy *= 0.96;
    s.x += s.vx; s.y += s.vy;
    s.angle += 0.0015 * ((i%2)?1:-1);

    // bounds
    if (s.x < s.w*0.45){ s.x = s.w*0.45; s.vx *= -0.6; }
    if (s.x > width - s.w*0.45){ s.x = width - s.w*0.45; s.vx *= -0.6; }
    if (s.y < s.h*0.45){ s.y = s.h*0.45; s.vy *= -0.6; }
    if (s.y > height - s.h*0.45){ s.y = height - s.h*0.45; s.vy *= -0.6; }

    // mild separation
    for (let j = 0; j < sprites.length; j++){
      if (i===j) continue;
      const o = sprites[j];
      const dx = s.x - o.x, dy = s.y - o.y;
      const d = sqrt(dx*dx + dy*dy);
      const minD = (s.w + o.w) * 0.28;
      if (d < minD && d > 0.1){
        const push = (minD - d) * 0.02;
        s.x += (dx/d) * push;
        s.y += (dy/d) * push;
      }
    }

    // push trail
    s.trail.push({x: s.x, y: s.y});
    if (s.trail.length > 20) s.trail.shift();

    // draw sparkly trail
    noStroke();
    for (let t = 0; t < s.trail.length; t++){
      const p = s.trail[t];
      const alpha = map(t,0,s.trail.length-1, 8, 160);
      fill(255, 230, 200, alpha * 0.9);
      ellipse(p.x, p.y, (s.w*0.12) * (t/s.trail.length + 0.2));
      fill(255,255,255, alpha*0.6);
      ellipse(p.x + 3*sin(t*0.6 + frameCount*0.02), p.y + 3*cos(t*0.4 + frameCount*0.02), 2);
    }

    // draw image
    push();
    translate(s.x, s.y);
    rotate(s.angle);
    imageMode(CENTER);
    image(s.img, 0, 0, s.w, s.h);
    pop();

    // shadow
    noStroke(); fill(0, 6);
    ellipse(s.x, s.y + s.h*0.48, s.w*0.92, s.h*0.18);
  }

  // HUD: count
  noStroke(); fill(6,60); textSize(13); textAlign(LEFT, TOP);
  text(sprites.length + ' cranes', 12, 12);
}

/* ---------- dragging & clicking ---------- */
let drag = null, dragOffsetX = 0, dragOffsetY = 0;

function mousePressed(){
  for (let i = sprites.length -1; i >= 0; i--){
    const s = sprites[i];
    const dx = mouseX - s.x, dy = mouseY - s.y;
    const dist = sqrt(dx*dx + dy*dy);
    if (dist < max(s.w, s.h) * 0.6){
      drag = s;
      dragOffsetX = s.x - mouseX;
      dragOffsetY = s.y - mouseY;
      // bring to front
      sprites.splice(i,1);
      sprites.push(drag);
      // chime and overlay
      playChime();
      showOverlayForSprite(s);
      return false;
    }
  }
}

function mouseDragged(){
  if (drag){
    drag.x = mouseX + dragOffsetX;
    drag.y = mouseY + dragOffsetY;
  }
}

function mouseReleased(){
  drag = null;
}

/* touch for mobile */
function touchStarted(){ return mousePressed(); }
function touchMoved(){ mouseDragged(); return false; }
function touchEnded(){ mouseReleased(); return false; }

/* ---------- overlay & chime ---------- */
function showOverlayForSprite(s){
  const overlay = document.getElementById('overlayInfo');
  const cont = document.getElementById('overlayContent');
  cont.innerHTML = `
    <img src="${s.url}" alt="crane">
    <h3 style="margin:6px 0">${escapeHtml(s.name) || 'Unnamed crane'}</h3>
    <p style="margin:0 0 6px">${escapeHtml(s.msg) || '<i>No message</i>'}</p>
    <small>Found: ${new Date(s.ts).toLocaleString()}</small>
  `;
  overlay.style.display = 'block';
}
document.getElementById('closeOverlay').addEventListener('click', ()=> {
  document.getElementById('overlayInfo').style.display = 'none';
});

/* chime via WebAudio */
let audioCtx = null;
function playChime(){
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(880, t);
    g.gain.setValueAtTime(0, t);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t);
    g.gain.linearRampToValueAtTime(0.15, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
    o.stop(t + 0.7);
  } catch(e){
    // fail silently if audio blocked
  }
}

/* ---------- upload UI handlers ---------- */
document.getElementById('uploadBtn').addEventListener('click', async () => {
  const fileEl = document.getElementById('file');
  const craneId = document.getElementById('craneId').value.trim();
  const name = document.getElementById('name').value.trim();
  const msg = document.getElementById('message').value.trim();

  if (!fileEl.files.length) { logStatus('choose a photo'); return; }
  if (!craneId) { logStatus('enter a crane id (e.g. C001)'); return; }

  logStatus('reading file...');
  const rawBase64 = await fileToBase64Str(fileEl.files[0]); // raw base64 (no prefix)
  logStatus('uploading...');
  try {
    // POST base64 as form data so Apps Script receives e.parameter.file
    const body = new URLSearchParams();
    body.append('file', rawBase64);
    body.append('craneId', craneId);
    // optionally include name/message in params (Apps Script code you used earlier may not handle them;
    // if you want them recorded in Sheets, use the fuller Apps Script variant that accepts JSON)
    body.append('name', name);
    body.append('message', msg);

    const res = await fetch(WEBAPP_URL, { method: 'POST', body: body });
    const json = await res.json();
    if (json.success) {
      logStatus('uploaded — reloading images...');
      // clear inputs
      fileEl.value = '';
      document.getElementById('name').value = '';
      document.getElementById('message').value = '';
      document.getElementById('craneId').value = '';
      // reload list (add small delay)
      setTimeout(loadServerImages, 1200);
    } else {
      logStatus('upload error: ' + (json.error || 'unknown'));
      console.warn('upload resp', json);
    }
  } catch (err) {
    console.error(err);
    logStatus('upload failed (see console)');
  }
});

/* manual refresh button */
document.getElementById('refreshBtn').addEventListener('click', async () => {
  logStatus('refreshing...');
  await loadServerImages();
  logStatus('idle');
});

/* ---------- utility ---------- */
function escapeHtml(str){ if(!str) return ''; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

</script>
</body>
</html>
